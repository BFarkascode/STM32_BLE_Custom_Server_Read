# STM32_BLE_Custom_Server_Read
Recreating a BLE service to do a readout of the BMP280 temperature sensor using CubeMx and the IDE.

## General description
Okay, this isn’t even a mini project but more of a micro project…

Simply put, I didn’t want to clog my notification project even further by discussing UUID numbers, function positions and introducing the BLE READ service. Here, I will do so quickly to have all basic BLE services and concepts covered.

## Going just a step further

### A few words on Universal Unique Identifiers (UUID)
All services and characteristics have their own designated “UUID” numbers. These numbers don’t matter much in case we want to generate our own service (we will just give them a random number or let CubeMx assign them), but they are essential in case we wish to build our application using existing services or if we want to talk to a client that expects a particular service.

Official UUID values are described in a pdf available on the official Bluetooth website.

The official BLE UUID values are always 16-bit wide while custom “vendor specific” ones are 128-bit wide. In CubeMX, we will always give only 16-bit values though when defining a custom UUID, the rest of the 112 bits being generated automatically for us for the custom one. This ensures that the likeliness of two custom services having the same UUID is practically none. This does not apply for standard UUID numbers which are always just 16-bit wide and cannot be anything else but the ones provided in the pdf.

The key word for UUID is “standardized”, meaning that there is an extremely high chance that we will come across the UUIDs from the pdf when we investigate an existing electronic device.

Anyway, in case we wish to have communication between and existing client or peripheral using our BLE server/client solution, we will have to respect the UUID services the existing client will ask for or the existing peripheral server will provide. Communicating with an existing commercial solution is not possible if we don’t know, which UUID services (and UUID characteristics) we need to expect/must generate – i.e., what data is coming our way from the peripheral or must be sent to by us.

In short, UUIDs are ways to standardize the communication protocol between devices using BLE but also are there to describe the content of the communication. The service UUID will tell, what the two devices can communicate between each other and the characteristic will tell, what they are communicating with the ongoing packet. From a technical point of view the service UUID will be used to form the packet’s protocol header, while the characteristics UUID will form the packet’s data header.

The UUIDs of a server’s services are sometimes found within the advertising data of the peripheral so we can know them without fully connecting to the server. If this is not the case, we can see the available services, their names, UUIDs and characteristics in a BLE scanner application after connecting to the device. The ST BLE Toolbox we are using for these projects have been pretty reliable for this purpose.

One last thing: lately I have come across multiple devices that were not possible to connect to using ST BLE Toolbox app. These devices could only be connected to through BLE using a designated third-party application with BLE privileges. I have not investigated this part of BLE, but it seems to me from the “BLE Advertising” tab in CubeMx that it would indeed be possible to set some kind of custom handshake for a server that would not be generated by a simple straight forward connection request, thus timing out the BLE connection. If one struggles to connect to a server, the likely culprit is going to be that the handshake is not generated properly.

### BLE Read
BLE read is very similar to BLE write (our uart pipe) in a sense that we aren’t using any tasks to have it executed and instead are using events to handle it. More precisely, apart from giving our newest (third) service’s characteristic the “read” property, we need to also enable the event “Read_req”. This will define a user code section within the “custom_stm.c” notification handler which will be executed upon a read request from the BLE stack (i.e., read request from the phone).

On the phone’s side, a characteristic with “READ” property will be shown as a button that, once pushed, will read out the value of the characteristic.

Mind, if the event is not enabled, no code section will be executed upon button push since the incoming request is not “interrupting” the sequencer. We won’t have an error message generated if the event is not enabled.

### Apps, tasks, functions and events
In the previous project, I was reflecting a bit on how “apps” are a bit confusingly named in the code since all activities across all services are handled by the same source code, that is, by “custom_app.c”. Now, I can refine this finding by saying that not all apps are tasks and functions can be executed by the sequencer without being wrapped into a task. In this sense, “apps” in WPAN are what “tasks” were in RTOS and “tasks” in WPAN are just what timer-based “tasks” in RTOS would be.

Mind, in order to ensure that a function is re-entrant, we must place them in the “FD” section of the “custom_app.c” source code. The I2CReadout function is blocking normally but since it is blocking through “HAL_Delay” – which is stored in the “FD” section of the “app_entry.c” source code – we won’t be breaking the sequencer with it. “FD” functions can be called from other source files without breaking entry. Local function prototypes go to “PFP” and “FD_LOCAL_FUNCTIONS” for each source code.

Speaking of “app_entry.c”, we are doing the usual I2C scanning and the extraction of the temperature constants coefficients in there before we initialise the sequencer. The “extern” variables we are using (such as the “device_addr”) is defined here within the “PV” private variable section, then called as externs in lower levels.

Lastly, following what was done within the “BLE_Sensor” example code provided by ST, I have reworked the events handling in “custom_stm.c”. As it turns out, the sequencer “apps” can be directly called from the events handler, thus allowing us to move all practical code execution to the    “custom_app.c”. Mind, the “Custom_STM_App_Notification” function must be called with the appropriate struct value/flag, otherwise the function will not execute the app we are looking for (i.e. the state machine will not go to the right case). The ID is the same as the case. The app case then can be filled with the code we wish to execute (here, upon READ request event, we will call the “CUSTOM_STM_TEMP_VALUE_READ_EVT” app, which then executes a temperature readout from the BMP280 and publish the value to the OLED screen, plus update the BLE characteristic’s value with the temperature data).

## Previous relevant projects:
We will be building upon the previous projects:

- STM32_BLE_Custom_Server_UART
- STM32_BLE_Custom_Server_Notify

## To read
For UUID, check the official site for more information:

https://www.bluetooth.com/specifications/assigned-numbers/

## Particularities
CubeMx should be set to introduce the third service called “Temp_read” with one read characteristic called “temp_value”. The value for the characteristic is set for constant 1 byte.

The two previous services remain unchanged.

## User guide
When doing a readout on our phone, we will have the temperature read out from the BMP280 and published it to the WB5MM’s OLED screen. At the same time, the temperature will be sent over to us as the value for the read characteristic’s value.

## Conclusion
Now we have all three basic BLE server actions – WRITE, NOTIFY and READ – working on our WB5MM. We should be now capable to recreate any basic BLE server, such as the official Environment Sensing Server, which runs the service UUID 181A with a temperature notify characteristic of UUID 2A6E. A challenge to do next?

